{"meta":{"title":"Lee的架构笔记","subtitle":"Lee的架构笔记@WorkerLee","description":"Java码农的分享与思考","author":"WorkerLee","url":"http://lili40342.github.io"},"pages":[{"title":"关于","date":"2020-06-25T13:01:27.226Z","updated":"2020-06-25T13:01:27.226Z","comments":true,"path":"about/index.html","permalink":"http://lili40342.github.io/about/index.html","excerpt":"","text":"关于博主13年Java开发老兵。2006年开始接触计算机开发。 专注 Java，Spring，Spring Boot，微服务，数据库等技术分享。 专注成为一名架构师，分享架构师干货，汇集各类奇妙好玩的架构师话题和流行的架构师动向。 如你需要敬请找我，我很乐意帮你。 开博缘由记录自己学到的技术和经验，分享给需要的朋友。 博客历史 2006年左右，最早的时候写博客就是在 QQ 空间。 2007年第一次在 CSDN 开博，期间就写了大概是五篇博文（长时间没维护，现已删除）。 2008 - 2011年工作实在太忙，长期出差，基本是没有维护过博文。 2012年买了第一服务器，用 WordPress 做起了个人博客。 2012 - 2018年，也是工作太忙了，以至于 WordPress 的服务器到期也忘记备份与续费，丢失了众多博文。 2019年，大病了一场，走一趟鬼门关，体会到了什么都没活着总要。 2020年，继续我的梦想······ 友情链接 GitHub CSDN社区 掘金社区 简书社区 交个朋友 微：lili40342 Q：24286057"}],"posts":[{"title":"Java中的ClassLoader","slug":"Java中的ClassLoader","date":"2020-06-25T13:03:04.849Z","updated":"2020-06-25T13:03:46.242Z","comments":true,"path":"2474365000.html","link":"","permalink":"http://lili40342.github.io/2474365000.html","excerpt":"","text":"基本概念ClassLoader 是一个重要的 Java 执行时系统组件，它负责在运行时查找和装入 Class 字节码文件。JVM 在运行时会产生三个ClassLoader：根装载器、扩展类装载器（ExtClassLoader）和系统类装载器（AppClassLoader）。其中，根装载器不是ClassLoader的子类，它使用C++编写，因此我们在 Java 中看不到它，根装载器负责装载JRE的核心类库，如JRE目标下的 rt.jar、charsets.jar 等。ExtClassLoader 和AppClassLoader 都是 ClassLoader 的子类。其中 ExtClassLoader 负责装载 JRE 目录 ext 中的 JAR 类包；AppClassLoader 负责装载 ClassPath 路径下的类包。 根装载器，这个类加载器负责将存放在 \\lib 目录中的。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。 扩展类加载器（Extension ClassLoader），这个加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 \\lib\\ext 目录中的，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader），这个类加载器由 sun.misc.Launcher$AppClassLoader 实现。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器。 我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。这些类加载器之间的关系一般为： 这三个类装载器之间存在父子层级关系，默认情况下，使用AppClassLoader装载应用程序的类，用以下代码证明： 12345678910111213package com.wlee.test;public class ClassLoaderTest &#123; public static void main(String[] args) &#123; //Thread.currentThread():返回对当前正在执行的线程对象的引用。 //getContextClassLoader():返回该线程的上下文ClassLoader。 ClassLoader loader = Thread.currentThread().getContextClassLoader(); System.out.println(\"当前的loader:\" + loader); System.out.println(\"父级的loader:\" + loader.getParent()); System.out.println(\"祖父级的loader:\" + loader.getParent().getParent()); &#125;&#125; 输出结果： 123当前的loader:sun.misc.Launcher$AppClassLoader@18b4aac2父级的loader:sun.misc.Launcher$ExtClassLoader@1d44bcfa祖父级的loader:null 通过以上的输出信息，很明显 ClassLoader 是 AppClassLoader，父 ClassLoader 是 ExtClassLoader，祖父 ClassLoader 是根类装载器，因为在 Java 中无法获得它，所以返回 null。 另外，ClassLoader 的几个重要方法： Class defineClass(String name, byte[] b, int off, int len) 将类文件的字节数组转换成JVM内部的java.lang.Class对象。字节数组可以从本地文件系统、远程网络获取。name为字节数组对应的全限定类名。 Class findSystemClass(String name) 从本地文件系统载入Class文件，如果本地文件系统不存在该Class文件，将抛出ClassNotFoundException异常。该方法是JVM默认使用的装载机制。 ClassLoader getParent() 获取类装载器的父装载器，除根装载器外，所有的类装载器都有且仅有一个父装载器，ExtClassLoader的父装载器是根装载器，因为根装载器非Java编写，所以无法获得，将返回null。 进阶 - 自定义ClassLoader首先我们自定义一个简单的类，并编译层 class 文件，放在指定的目录下，比如 d:/test/ 目录下，类代码如下： 12345package com.wlee.test;public class App &#123; private String name = \"测试App\";&#125; 这个类编译之后把编译好的 class 文件放在 d:/test/ 目录下，也就是文件路径是 d:/test/App.class，自定义 ClassLoader 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.wlee.test;import org.apache.commons.io.IOUtils;import org.apache.commons.lang3.reflect.FieldUtils;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.Field;public class MyClassLoader extends ClassLoader &#123; private String path = \"d:/test/\"; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; Class&lt;?&gt; cls = findLoadedClass(name); if (cls != null) &#123; return cls; &#125; if (!name.endsWith(\".App\")) &#123; return super.loadClass(name); &#125; try &#123; InputStream is = new FileInputStream(path + name.replace(\".\", \"/\") + \".class\"); byte[] bytes = IOUtils.toByteArray(is); return defineClass(name, bytes, 0, bytes.length); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return super.loadClass(name); &#125; public static void main(String[] args) &#123; try &#123; MyClassLoader loader = new MyClassLoader(); Class&lt;?&gt; cls = loader.loadClass(\"com.wlee.test.App\"); Field field = FieldUtils.getField(cls, \"name\", true); Object value = field.get(cls.newInstance()); System.out.println(value); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行main方法之后，自定义类加载器正常加载到类，程序最后输出：测试App。 代码很简单，上面那个 main 方法，就是读取自定义的目录。其实可以直接使用 URLClassLoader 就能读取： 1234567891011public static void main(String[] args) &#123; try &#123; URLClassLoader loader = new URLClassLoader(new URL[]&#123;new URL(\"file:///d:/test/\")&#125;); Class&lt;?&gt; cls = loader.loadClass(\"com.wlee.test.App\"); Field field = FieldUtils.getField(cls, \"name\", true); Object value = field.get(cls.newInstance()); System.out.println(value); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"渐行渐远的JSP","slug":"渐行渐远的JSP","date":"2020-06-25T13:03:04.847Z","updated":"2020-06-25T13:04:28.467Z","comments":true,"path":"2242648824.html","link":"","permalink":"http://lili40342.github.io/2242648824.html","excerpt":"","text":"写在前面最近几天看到一篇博文，说解析 JSP 的文章，文章作者从接触开发一直到现在，将 JSP 分析有条有理，而且文章中还有一部分是回忆过往的回想，让本作者看到以后十分感慨。结合这些年一路走来，让自己也陷入沉思。 回忆作者是一位10+年时间的老码农，回忆了一下第一次接触所谓的计算机语言那是上大学的时候。那个时候对于自己来说，这些所谓的计算机语言，那是它们认识我，我却不认识它们。记得学习第一门语言是 Pascal 这门课，记忆最深的就是老师课堂上说的那句话“Pascal 语言是一切语言的基础，学会它再学别的语言就简单”。至于我为什么记着这句话，一会再说。面对黑板上密密麻麻的指令，我当时只能说一句“这都是些什么东西”。转眼间第二个学期，又一门语言，C 语言，然后就提到刚才那句记忆尤新的话“C 语言是一切语言的基础，学会它再学别的语言就简单”。好吧，幸亏上学期没好好学 Pascal，转眼一年过去了，一切计算机语言的基础一下子换了个主。说到了这里了，有人就想问作者，你什么时候上的大学？！我只能说我上大学的时候，手机都不普及，上网都是64k猫拨号，大二的时候才刚普及网吧。不多说了，再多说就可以穿越了。 正题第一次接触 JSP 的时候，仔细的回忆了一下，应该是在2004年 - 2005年之间吧，具体的实在想不起来了。那个时候就感觉这个 JSP 好强大。当时也不懂什么 MVC，甚至就连数据库的 JDBC 连接都写在 JSP 页面中。当初在页面中又是读数据库又是定义 List 集合，然后各种处理，写出一个分页来，那是多么无比牛X外加炫酷，为了这个历史时刻，还特意的分享到了 QQ 空间炫耀了一把（到现在我还能找到这篇QQ文章）。 然后用 JSP 做的第一个项目就是给一个政府机构做一个网站，当初自己技术不好，为了能拿下这个政府网站的项目，公司特意和一个专门从事这个行业的公司合作做的，为了是以后能开拓这个行业的行业项目。那时候我就奔波与本地与北京之间（那个时候去北京记得好像就两趟快车，早晚各一趟，单程需要5个半小时），话说一个网站有什么复杂的，如果用现在的思维定论去看当时的那个网站，感觉那个时候自己太low了。这个项目是真学到东西了，MVC ?原来是这么回事，从控制器里取数据传递到 JSP 中。晕？Servlet ？什么什么 doGet 和 doPost，emm。啥？Struts 框架？Winform？为什么是这样？除了网站还有一部分行业项目。各种疑惑与疑虑，各种怀疑人生，当时就想还是人家技术牛。勉强跟着人家终于学了些东西，之后把人家的另外一个行业项目拿下，然后终于可有自己去完成这个项目。后来离开了这个公司，至于为什么离开，原因很简单，公司有一个做 PB 和 Delphi 的元老，当时很谦虚的和他一起搞项目，但是他的编程思想实在是不敢恭维，他实在是接受不了我们这些 B/S 架构的软件开发模式。成天把一句话挂自己嘴边“我有10年开发软件的经验…”，您自己慢慢10年吧，我不干了。 辞职换了一个公司，接触了风靡一时的 SSH 框架，然后再接触到 ExtJS，当时为了能做出一个效果，那是真绞尽脑汁，到处问，到处搜，那个时候有关于 ExtJS 的文章还不多。后来还碰见公司一个 ExtJS 牛人，问他为何这么精通 ExtJS，得知他是按照 ExtJS 的 API 一点一点的试的。然后就是更高级点的 Web 服务器，WebLogic 和 WebSphere等吧，然后跟着学各种配置，那是超级晕菜啊。 当时就抱着 JSP 就没放过，记得当初另外一个项目现场用的是 FreeMarker 模板做页面，要把我派到那个现场做开发，实在不爱学也不爱搞，就特意给领导申请不去那里。 时间变迁这些年过来，随着时间的推移，技术的更新换代，不管你是在学校学的，还是在培训机构培训的，JSP 应该一下子就带过了。一个现代主流 Java Web 应用，不管前端、后端、还是微服务架构，都在淘汰 JSP。如果还埋怨以前的开发前后端不好分离的话，而现在前后端分离已经不是什么趋势了，而是当前 B/S 架构开发的主流模式了。前端框架已经非常成熟和稳定，不需要 JSP。前后端分离之后，前端只负责展现和交互，后端负责核心业务逻辑。前后端通过 API 进行交互，并且最好符合 RESTful 风格。服务器端把数据返回给前端就不再关心这些数据用在哪里、如何布局、什么样式。 服务器端的 Spring MVC/WebFlux 和 Spring Boot 已经开始抛弃 JSP。从 Spring 5 开始，在原有的基于 Servlet 技术的 Spring MVC 之外增加了一个新的编程模型，就是 Spring WebFlux。Spring WebFlux 是响应式非阻塞的，而且不支持 Servlet API，所以也就不支持 JSP了。至少 Spring MVC 还是支持 JSP 的，个人认为现在已经快是 Spring Boot 的天下了，Spring MVC 都快渐行渐远了。有人说了 Spring Boot 是支持 JSP 的，是的是支持的。 其实用 Spring Boot 的人都知道，它默认的模板引擎是什么？先不管是什么，肯定不是 JSP。是的， Spring Boot 是支持 JSP的，但是 Spring Boot 对 JSP 是有限制的，只能凑合着用 JSP。这里就不去研究到底有什么限制，官方文档里都有说明，而且网上一搜一大把。 好吧，我们继续说一下 Spring Cloud。因为有 Spring Boot 对 JSP 的限制，而 Spring Cloud 的组成部分是 Spring Boot 应用，所以 Spring Cloud 也对 JSP 有限制。其实不仅仅是表面上这个原因，咱们继续分析。 如果强行继续在Spring Cloud环境中继续使用JSP，那么JSP放在哪里？有两种方案吧： API Gateway 和每个 MicroService 里面都有 @Controller 以及对应的 JSP。那么这种方案下，不同微服务中的 JSP 如何通信？用户访问的时候，同一个应用下的所有 JSP 页面会在不同 IP 和端口下来回变换。一会是 ip0:8081/xxx/xxx.jsp，一会是 ip1:8082/xxx/xxx.jsp，点个连接又跳转到 ip2:8080/xxx/xxx.jsp. 把整个微服务应用下的所有 @Controller 和 JSP 都放在 API Gateway 里面，其他 Microservice 中只有提供 REST API 的 @Controller 和 @Service。这种方案并不算理想的微服务架构，因为 Gateway 没有解耦，里面的所有 @Controller 不能拆分部署。这样就相当于在 MicroService 架构下有了一个局部的 Monolithic(单体应用)。 以上的方案实在不愿去继续思考了，用一句现在流行的话说就是“太蛋疼了”。其实都已经 Spring Cloud 了，前后端分离开发势在必行了，再用 JSP 就无法完美拆分微服务，无法利用微服务本应带来的各种优势。 就这么多吧文中的内容有摘抄，有自己叙述，有自己见解，不代表任何一方，个人想法而已。现在 JSP 处于被前后端夹击的状态，生存空间越来越小了。就算你不打算管前端，只想在服务器端有所建树。微服务的前提也必须前后端分离。如果你还继续 JSP（别闹好吗），服务器端只能停留在 SSH/SSM 阶段，用 Spring Boot + Spring MVC 已经最高领域了。","categories":[],"tags":[],"keywords":[]},{"title":"另类分析String，StringBuffer和StringBuilder","slug":"另类分析String，StringBuffer和StringBuilder","date":"2020-06-25T13:02:41.824Z","updated":"2020-06-12T17:04:44.344Z","comments":true,"path":"3742853179.html","link":"","permalink":"http://lili40342.github.io/3742853179.html","excerpt":"","text":"开始String，StringBuffer 和 StringBuilder 直接的区别这个问题已经是一个老问题了，尤其是在面试的时候会被经常提及的问题。首先 String 类型并不是 Java 语言的基本类型，它是 Java 中非常重要的一个引用类型（对象）。String 字符串一旦被创建出来就不会被修改，当你想修改 StringBuffer 或者是 StringBuilder，出于效率的考量，虽然 String 可以通过 + 来创建多个对象达到字符串拼接的效果，但是这种拼接的效率相比 StringBuffer 和 StringBuilder，效率上就差了点。 String上面说到，String 字符串一旦被创建出来就不会被修改，其实很好理解。我们查看 String 类的源码即可得知（代码片段）： 1234567public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; ...... ...... ...... 上面代码其中 String 类已经被 final 修饰，用于存放字符的数组也被声明为 final，因此只能赋值一次，不可再更改。使用 final 修饰的类不能被继承、方法不能被重写、属性不能被修改。阅读了源码之后就能知道，String 类它其中的方法也是由 final 修饰的，所以，String 类就是一个典型的 Immutable 类。也由于 String 的不可变性，类似字符串拼接、字符串截取等操作都会产生新的 String 对象。所以我们在研究 String 的时候就会引入一个概念叫做“常量池”，如果再深入的话就会碰到堆与栈的问题了。研究那么深其实并没有太大的实际意义，毕竟我们都是以实用为主，所以我们只做基本性质的讨论。 请看以下示例： 12345678910111213package com.wlee.test;public class StringTest &#123; public static void main(String[] args) &#123; String str1 = \"aaa\"; String str2 = \"bbb\" + \"ccc\"; String str3 = str1 + \"bbb\"; String str4 = new String(\"aaa\"); &#125;&#125; 这里定义了4个 String 类型的变量，我们逐个的分析一下，这里我们可以用 JDK 自带的反编译工具对生成的 class 文件进行反汇编代码即可。 javap 是 JDK 自带的反汇编工具。它的作用就是根据 class 字节码文件，反汇编出当前类对应的 code 区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等等信息。javap -c 就是对代码进行反汇编操作。命令格式：javap -c xxxx.class 下面就是我反编译之后的信息： 1234567891011121314151617181920212223242526272829303132D:\\workspace_idea\\string_demo\\target\\classes\\com\\wlee\\test&gt;javap -c StringTest.classCompiled from &quot;StringTest.java&quot;public class com.wlee.test.StringTest &#123; public com.wlee.test.StringTest(); Code: 0: aload_0 1: invokespecial #1 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: ldc #2 &#x2F;&#x2F; String aaa 2: astore_1 3: ldc #3 &#x2F;&#x2F; String bbbccc 5: astore_2 6: new #4 &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder 9: dup 10: invokespecial #5 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V 13: aload_1 14: invokevirtual #6 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder; 17: ldc #7 &#x2F;&#x2F; String bbb 19: invokevirtual #6 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder; 22: invokevirtual #8 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String; 25: astore_3 26: new #9 &#x2F;&#x2F; class java&#x2F;lang&#x2F;String 29: dup 30: ldc #2 &#x2F;&#x2F; String aaa 32: invokespecial #10 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;String.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V 35: astore 4 37: return&#125; 解释一下（默认情况下，常量池为空时）： String str1 = “aaa”，str1 创建了几个对象？字符串在创建对象时，会在常量池中看有没有 aaa 这个字符串。如果没有此时还会在常量池中创建一个，如果有则不创建。默认情况下所以会创建一个对象。 String str2 = “bbb” + “ccc”，那么这个 str2 会创建几个对象？其实我们可以通过上述的反编译信息可以得知，str2 会直接创建一个 bbbccc 的对象。 String str3 = str1 + “bbb”，这个 str3 又是如何工作的？再看一下反编译信息： 123456789101112131415 public static void main(java.lang.String[]); Code: 0: ldc #2 &#x2F;&#x2F; String aaa 2: astore_1 3: ldc #3 &#x2F;&#x2F; String bbbccc 5: astore_2 6: new #4 &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuilder 9: dup 10: invokespecial #5 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.&quot;&lt;init&gt;&quot;:()V 13: aload_1 14: invokevirtual #6 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder; 17: ldc #7 &#x2F;&#x2F; String bbb 19: invokevirtual #6 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuilder; 22: invokevirtual #8 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuilder.toString:()Ljava&#x2F;lang&#x2F;String;&#125; 很明显，str3 先创建了一个 StringBuilder 对象并执行了初始化，然后在 str3 中执行 + 号其实是执行了 StringBuilder 的 append() 操作，最后还调用了一个 StringBuilder 的 toString 方法。说白了，String str3 = str1 + “bbb” 就等价于 String str3 = new StringBuilder().append(str1).append(“bbb”).toString()，所以 str3 执行结束后，相当于创建了3个对象。 String str4 = new String(“aaa”)，最后就是 str4 了，这个就很好理解了，在创建这个对象时因为使用了 new 关键字，所以肯定会在堆中创建一个对象。然后会在常量池中看有没有 aaa 这个字符串，如果没有此时还会在常量池中创建一个，如果有则不创建。所以可能是创建一个或者两个对象，但是一定存在两个对象。 String 就讲到这里吧，看完上面的分析发现 String 对象竟然和 StringBuilder 有关联，String 对象底层是使用了 StringBuilder 对象的 append 方法进行字符串进行拼接的。我们就不再深入讨论“堆与栈”的问题了，因为它已经是老生常谈的问题了。 StringBufferStringBuffer 代表一个可变的字符串序列，当一个 StringBuffer 被创建以后，通过 StringBuffer 的一系列方法可以实现字符串的拼接、截取等操作。一旦通过 StringBuffer 生成了最终想要的字符串后，就可以调用其 toString 方法来生成一个新的字符串。请看如下代码： 12345678910package com.wlee.test;public class StringTest &#123; public static void main(String[] args) &#123; StringBuffer strBuffer = new StringBuffer(\"123\"); strBuffer.append(\"abc\"); System.out.println(strBuffer); &#125;&#125; 我们将这个类的 class 文件反编译一下看到如下信息： 1234567891011121314151617181920212223D:\\workspace_idea\\string_demo\\target\\classes\\com\\wlee\\test&gt;javap -c StringTest.classCompiled from &quot;StringTest.java&quot;public class com.wlee.test.StringTest &#123; public com.wlee.test.StringTest(); Code: 0: aload_0 1: invokespecial #1 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V 4: return public static void main(java.lang.String[]); Code: 0: new #2 &#x2F;&#x2F; class java&#x2F;lang&#x2F;StringBuffer 3: dup 4: ldc #3 &#x2F;&#x2F; String 123 6: invokespecial #4 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuffer.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V 9: astore_1 10: aload_1 11: ldc #5 &#x2F;&#x2F; String abc 13: invokevirtual #6 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;StringBuffer.append:(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;StringBuffer; 16: pop 17: return&#125; 从上述反编译信息可以看出 StringBuffer 在 append 的时候，并不会自动调用 toString 方法，这和之前 String 对象 在用 + 拼接的时候会自动调用 toString 方法和截然不同。其实很好理解，这里是 StringBuffer 对象，如果你想从 StringBuffer 对象获取 String 对象，你必须手动的进行调用 toString 方法。 我们也可以通过源码看到 StringBuffer 是线程安全的，它在字符串拼接上面直接使用 synchronized 关键字加锁，从而保证了线程安全性。 StringBuilderStringBuilder 是在 Java5 中被提出，它其实是和 StringBuffer 几乎一样，它和 StringBuffer 之间的最大不同在于 StringBuilder 是非线程安全的（不能同步访问），所以在常规情况下 StringBuilder 相较于 StringBuffer 有速度优势，并且为什么 + 号操作符使用 StringBuilder 作为拼接条件而不是使用 StringBuffer 呢？我觉得就是这个所谓加锁耗时会影响性能，所以 String 底层使用 StringBuilder 作为字符串拼接，所以多数情况下建议使用 StringBuilder 类。 我们再用一个段代码来说明 StringBuilder 的效率： 1234567891011package com.wlee.test;public class StringTest &#123; public static void main(String[] args) &#123; String s = \"123\"; for (int i = 0; i &lt; 100000; i++) &#123; s += \"ab\"; &#125; &#125;&#125; 这段代码根据我们之前分析的，String 在使用 + 拼接时，JVM 会隐式创建 StringBuilder 对象，在大部分情况下不会造成效率的损失，不过在进行大量循环拼接字符串时就不不行了，按照刚才反编译的信息看，上述代码其实就是成了： 1234String s &#x3D; &quot;123&quot;;for(int i &#x3D; 0; i &lt; 10000; i++) &#123; s &#x3D; (new StringBuilder()).append(s).append(&quot;ab&quot;).toString(); &#125; 在每次进行循环时，都会创建一个 StringBuilder 对象，每次都会把一个新的字符串元素 ab 拼接到 123 的后面，就成了如下结果： 12345678910new StringBuilder() String s &#x3D; 123ab;new StringBuilder() String s &#x3D; 123abab;new StringBuilder() String s &#x3D; 123ababab;new StringBuilder() String s &#x3D; 123abababab;new StringBuilder() String s &#x3D; 123ababababab;new StringBuilder() String s &#x3D; 123abababababab;new StringBuilder() String s &#x3D; 123ababababababab;.................. 每次都会创建一个 StringBuilder ，并把引用赋给 StringBuilder 对象，这样在创建完毕后，内存中就会多了很多 StringBuilder 的无用对象。这样由于大量 StringBuilder 创建在内存中，肯定会造成效率的损失，所以在这种情况下建议在循环体外创建一个 StringBuilder 对象调用 append() 方法手动拼接。如下代码： 123456789101112package com.wlee.test;public class StringTest &#123; public static void main(String[] args) &#123; StringBuilder strBuilder = new StringBuilder(\"123\"); for (int i = 0; i &lt; 10000; i++) &#123; strBuilder.append(\"ab\"); &#125; strBuilder.toString(); &#125;&#125; 这段代码中，只会创建一个 StringBuilder 对象，每次循环都会使用这个 StringBuilder 对象进行拼接，因此提高了拼接效率。 结语以上对 String，StringBuffer 和 StringBuilder 的分析，并没有像其他网友那样对它们进行用法以及功能上的比对，只是相互之间进行了分析而已，正常没有特别要求的情况下，StringBuffer 和 StringBuilder 用哪个都可以，StringBuffer 与 StringBuilder 最大的区别就是 StringBuffer 可以在多线程场景下使用，StringBuffer 内部有大部分方法都加了 synchronized 锁。在单线程场景下效率比较低，因为有锁的开销。","categories":[],"tags":[],"keywords":[]},{"title":"Java中的泛型","slug":"Java中的泛型","date":"2020-06-25T13:02:41.823Z","updated":"2020-06-14T19:39:46.111Z","comments":true,"path":"2784153059.html","link":"","permalink":"http://lili40342.github.io/2784153059.html","excerpt":"","text":"开始Java 泛型（generics）是 JDK 5 中引入的一个新特性，泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。作者印象中第一次接触泛型的时候应该是在学习集合的时候，今天再详细的的讨论下泛型。 1234567891011121314package com.wlee.test;import java.util.ArrayList;import java.util.List;public class GenericTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"123\"); list.add(\"abc\"); list.add(123); //这里明显会报错 &#125;&#125; 上面很简单的例子，这里可以看出来在代码编写阶段就已经报错了，不能往 String 类型的集合中添加 int 类型的数据。那可不可以往 List 集合中添加多个类型数据呢，那肯定是可以的，其实我们可以把 List 集合当成普通的类也是没问题的： 1234567891011121314package com.wlee.test;import java.util.ArrayList;import java.util.List;public class GenericTest &#123; public static void main(String[] args) &#123; List list = new ArrayList(); list.add(\"123\"); list.add(\"abc\"); list.add(123); //这里就没有问题了 &#125;&#125; 以上代码，就可以得知不定义泛型也是可以往集合中添加数据的，所以说泛型只是一种类型的规范，在代码编写阶段起一种限制。 下面我们通过例子来介绍泛型背后数据是什么类型： 12345678910111213package com.wlee.test;public class BasePojo&lt;T&gt; &#123; T val; public void setVal(T val) &#123; this.val = val; &#125; public T getVal() &#123; return val; &#125;&#125; 上面定义了一个泛型的类，然后我们通过反射获取属性和 getValue 方法返回的数据类型： 123456789101112131415161718192021222324252627282930package com.wlee.test;import java.lang.reflect.Field;import java.lang.reflect.Method;public class GenericTest &#123; public static void main(String[] args) &#123; //实例对象 并 赋值 BasePojo&lt;String&gt; basePojo = new BasePojo&lt;String&gt;(); basePojo.setVal(\"WorkerLee\"); try &#123; //获取属性上的泛型类型 Field fieldVal = basePojo.getClass().getDeclaredField(\"val\"); Class&lt;?&gt; type = fieldVal.getType(); String typeName = type.getTypeName(); System.out.println(\"type:\" + typeName); //获取方法上的泛型类型 Method getVal = basePojo.getClass().getDeclaredMethod(\"getVal\"); Object objInvoke = getVal.invoke(basePojo); String methodName = objInvoke.getClass().getName(); System.out.println(\"methodName\" + methodName); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 12type:java.lang.ObjectmethodNamejava.lang.String 从结果上看到通过反射获取到的属性是 Object 类型的，在方法中返回的是 String 类型，其实它在 getVal 方法里面实际是做了个强转的动作，将 Object 类型的 val 强转成 String 类型。说白了这里就是咱们经常说“装箱，拆箱”那些事。 泛型只是为了约束我们规范代码，而对于编译完之后的 class 交给虚拟机后，对于虚拟机它是没有泛型的说法的，所有的泛型在它看来都是 Object 类型。其实很好理解，我把上面定义的 BasePojo 稍微修改： 12345678910111213package com.wlee.test;public class BasePojo&lt;T extends String&gt; &#123; T val; public void setVal(T val) &#123; this.val = val; &#125; public T getVal() &#123; return val; &#125;&#125; 这里我们将泛型加了个关键字 extends，extends 是约束了泛型是向下继承的，最后我们通过反射获取 val 的类型是 String 类型的，加上了 extends 关键字其实就是约束泛型是属于哪一类的。所以我们在编写代码的时候如果没有向下兼容类型，会警告报错。 12//这里用Long肯定就直接报错了BasePojo&lt;Long&gt; basePojo = new BasePojo&lt;Long&gt;(); 既然泛型其实对于 JVM 来说都是 Object 类型的，咱们直接将类型定义成 Object 不就行了，这种做法是没问题的。但是您拿到 Object 类型值之后不是还得自己进行强转，定义了泛型减少了我们的强转工作，而将这些工作交给了虚拟机岂不是美滋滋。那么泛型的好处就是在编译的时候能够检查类型安全，并且所有的强制转换都是自动和隐式的。 泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。 泛型用在哪常见的泛型主要有作用在普通类上面，作用在抽象类、接口、静态或非静态方法上：。 方法上面的泛型： 123public &lt;T&gt; T getData() &#123; return null;&#125; 类上面的泛型： 12345public class Result&lt;T&gt; &#123; public String code; public String msg; public T data;&#125; 抽象类或接口上的泛型： 123456789101112131415//抽象类泛型public abstract class TestService&lt;T&gt; &#123; public List&lt;T&gt; resultList;&#125;//接口泛型public interface TestService&lt;T&gt; &#123; public T delete();&#125;//二级抽象类public abstract class TestService&lt;K extends Common, V&gt; implements Base&lt;K, V&gt; &#123;&#125;//二级接口public interface TestService&lt;K extends Common, V&gt; extends Base&lt;K, V&gt; &#123;&#125; 多元泛型： 12345public interface TestService&lt;K, V&gt; &#123; public void setKey(K k); public V getVal();&#125; 泛型中通配符我们在定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符，比如 T，E，K，V，? 等等。本质上这些通配符没太大区别，只不过是编码时起一种代码约定的作用。一般情况下 T，E，K，V，？是这样约定的： ？表示不确定的 Java 类型 T (type) 表示具体的一个 Java 类型，而且 T 完全可以用 A-Z 之间的任何一个字母代替 K V (key value) 分别代表 Java 键值中的 Key Value E (element) 代表 Element ？无界通配符通配符其实在声明局部变量时是没有太多的意义，但是当你为一个方法声明一个参数时，它是挺重要的。举个例子吧，比如有一个父类 Animal 和 两个子类 Bird 和 Dog： 1234567891011121314151617181920212223242526272829303132333435public class Animal &#123;&#125;public class Bird extends Animal &#123;&#125;public class Dog extends Animal &#123;&#125;public class GenericTest &#123; //通配符用来定义变量时是没有太多意义 //List&lt;Animal&gt; listAnimals1; //List&lt;? extends Animal&gt; listAnimals2; //主要按一下两个方法 test1 和 test2 public static void test1(List&lt;? extends Animal&gt; animals) &#123; //方法内容略 &#125; public static void test2(List&lt;Animal&gt; animals) &#123; //方法内容略 &#125; public static void main(String[] args) &#123; List&lt;Bird&gt; birds = new ArrayList&lt;Bird&gt;(); //调用test1不报错 GenericTest.test1(birds); //调用test2肯定是报错的 GenericTest.test2(birds); //报错 &#125;&#125; 以上代码很好理解，test2 方法要求需要一个 Animal 的 List，传递 Bird 的 List 肯定报错。所以，对于不确定或者不关心实际要操作的类型，可以使用无界通配符（就是那个问号），表示可以持有任何类型。像 test1 方法中，限定了上届，但是不关心具体类型是什么，所以对于传入的 Animal 的所有子类都可以支持，并且不会报错。而 test2 就不行。 上界通配符与下界通配符上界通配符与下界通配符其实很好理解。 上界通配符，其实就是用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类，用来限定泛型的上界。 下界通配符，就是用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object，用来限定泛型的下界。 代码示例： 1234567891011121314151617181920212223//水果类 继承 食物public class Fruit extends Food &#123;&#125;//桔子类 继承 水果public class Orange extends Fruit &#123;&#125;//定义了一个 篮子 类public class Basket&lt;T&gt;&#123; private T item; public void set(T item) &#123; this.item = item; &#125; public T get() &#123; return item; &#125;&#125; 现在我们定义一个”Fruit Basket 水果篮子”，按照现实逻辑，Orange Basket 当然是 Fruit Basket 的一种。按照 Java 中父类和子类的使用规范，子类 Orange Basket 当然可以赋值给父类 Fruit Basket。代码就是这样的： 1Basket&lt;Fruit&gt; fruitBasket = new Basket&lt;Orange&gt;(); //ide报错，类型无法转换 以上代码肯定是报错的，其实很好理解，Orange 和 Fruit 是父子关系，但是相应的 Basket 却不是父子关系。那怎么解决这个问题？使用上界通配符来处理这种关系： 1Basket&lt;? extends Fruit&gt; fruitBasket = new Basket&lt;Orange&gt;(); 反过来思考，把 Fruit Basket 赋值给 Food Basket 是否可以？使用下界通配符来处理这种关系： 1Basket&lt;? super Fruit&gt; orangeBasket = new Basket&lt;Food&gt;(); ？和 T 的区别简单总结下：T 是一个“确定的”类型，通常用于泛型类和泛型方法的定义。？ 是一个“不确定”的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。通过 T 来 确保 泛型参数的一致性，类型参数可以多重限定而通配符不行，通配符可以使用超类限定而类型参数不行。","categories":[],"tags":[],"keywords":[]},{"title":"HashMap是如何遍历的","slug":"HashMap是如何遍历的","date":"2020-06-25T13:02:41.823Z","updated":"2020-06-17T13:52:36.542Z","comments":true,"path":"400897285.html","link":"","permalink":"http://lili40342.github.io/400897285.html","excerpt":"","text":"前言其实用上 JDK1.8 才是近些时日的事，毕竟没有什么新的技术点必须要去用，也懒得去换 JDK 的版本了。这几天在某论坛里看到一个有关于“HashMap如何遍历”的问题，静心一想也就知道那么一两种，于是想了想还是总结总结吧。 遍历方式大概的总结了一下，HashMap 遍历就是分大概4个方向吧： 迭代器（Iterator）方式遍历。 For Each 方式遍历。 Lambda 表达式遍历（JDK1.8加入的）。 Streams API 遍历（JDK1.8加入的）。 大概方向是这么几个，但是遍历方法也不少，一一举例吧。 有的朋友问我怎么我按顺序赋值怎么遍历出来顺序都不对啊，您是不是忘了一件事，Map里面是无序的O(∩_∩)O （1）用 EntrySet 迭代器123456789101112131415161718192021222324252627package com.wlee.test;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class Test &#123; //定义一个Map public static Map&lt;String, String&gt; testMap = new HashMap() &#123;&#123; for (int i = 0; i &lt; 10; i++) &#123; put(\"key\" + i, \"val\" + i); &#125; &#125;&#125;; public static void entrySetTest() &#123; Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = testMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = iterator.next(); System.out.println(entry.getKey() + \" ------ \" + entry.getValue()); &#125; &#125; public static void main(String[] args) &#123; Test.entrySetTest(); &#125;&#125; （2）用 KeySet 迭代器123456789101112131415161718192021222324252627package com.wlee.test;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class Test &#123; //定义一个Map public static Map&lt;String, String&gt; testMap = new HashMap() &#123;&#123; for (int i = 0; i &lt; 10; i++) &#123; put(\"key\" + i, \"val\" + i); &#125; &#125;&#125;; public static void keySetTest() &#123; Iterator&lt;String&gt; iterator = testMap.keySet().iterator(); while (iterator.hasNext()) &#123; String key = iterator.next(); System.out.println(key + \" ------ \" + testMap.get(key)); &#125; &#125; public static void main(String[] args) &#123; Test.keySetTest(); &#125;&#125; （3）用 ForEach 处理 EntrySet12345678910111213141516171819202122232425package com.wlee.test;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class Test &#123; //定义一个Map public static Map&lt;String, String&gt; testMap = new HashMap() &#123;&#123; for (int i = 0; i &lt; 10; i++) &#123; put(\"key\" + i, \"val\" + i); &#125; &#125;&#125;; public static void forEach4EntrySetTest() &#123; for (Map.Entry&lt;String, String&gt; entry : testMap.entrySet()) &#123; System.out.println(entry.getKey() + \" ------ \" + entry.getValue()); &#125; &#125; public static void main(String[] args) &#123; Test.forEach4EntrySetTest(); &#125;&#125; （4）用 ForEach 处理 KeySet12345678910111213141516171819202122232425package com.wlee.test;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class Test &#123; //定义一个Map public static Map&lt;String, String&gt; testMap = new HashMap() &#123;&#123; for (int i = 0; i &lt; 10; i++) &#123; put(\"key\" + i, \"val\" + i); &#125; &#125;&#125;; public static void forEach4KeySetTest() &#123; for (String key : testMap.keySet()) &#123; System.out.println(key + \" ------ \" + testMap.get(key)); &#125; &#125; public static void main(String[] args) &#123; Test.forEach4KeySetTest(); &#125;&#125; （5）用 Lambda12345678910111213141516171819202122232425package com.wlee.test;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class Test &#123; //定义一个Map public static Map&lt;String, String&gt; testMap = new HashMap() &#123;&#123; for (int i = 0; i &lt; 10; i++) &#123; put(\"key\" + i, \"val\" + i); &#125; &#125;&#125;; public static void lambdaTest() &#123; testMap.forEach((key, value) -&gt; &#123; System.out.println(key + \" ------ \" + value); &#125;); &#125; public static void main(String[] args) &#123; Test.lambdaTest(); &#125;&#125; （6）用 StreamsAPI 的单线程12345678910111213141516171819202122232425package com.wlee.test;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class Test &#123; //定义一个Map public static Map&lt;String, String&gt; testMap = new HashMap() &#123;&#123; for (int i = 0; i &lt; 10; i++) &#123; put(\"key\" + i, \"val\" + i); &#125; &#125;&#125;; public static void streamTest() &#123; testMap.entrySet().stream().forEach((entry) -&gt; &#123; System.out.println(entry.getKey() + \" ------ \" + entry.getValue()); &#125;); &#125; public static void main(String[] args) &#123; Test.streamTest(); &#125;&#125; （7）用 StreamsAPI 的多线程12345678910111213141516171819202122232425package com.wlee.test;import java.util.HashMap;import java.util.Iterator;import java.util.Map;public class Test &#123; //定义一个Map public static Map&lt;String, String&gt; testMap = new HashMap() &#123;&#123; for (int i = 0; i &lt; 10; i++) &#123; put(\"key\" + i, \"val\" + i); &#125; &#125;&#125;; public static void parallelStreamTest() &#123; testMap.entrySet().parallelStream().forEach((entry) -&gt; &#123; System.out.println(entry.getKey() + \" ------ \" + entry.getValue()); &#125;); &#125; public static void main(String[] args) &#123; Test.parallelStreamTest(); &#125;&#125; 大概是总结了7种遍历方式，当然可能不一定就只有这7种，还需要朋友们多多指教。有时候您会问这些方式都哪些方式更快，性能更好。其实各种遍历方式差别不是很大。 番外篇（性能测试）Maven 项目请先引入： 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt; &lt;artifactId&gt;jmh-core&lt;/artifactId&gt; &lt;version&gt;1.23&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.openjdk.jmh&lt;/groupId&gt; &lt;artifactId&gt;jmh-generator-annprocess&lt;/artifactId&gt; &lt;version&gt;1.20&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 然后测试类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package com.wlee.test;import org.openjdk.jmh.annotations.*;import org.openjdk.jmh.runner.Runner;import org.openjdk.jmh.runner.RunnerException;import org.openjdk.jmh.runner.options.Options;import org.openjdk.jmh.runner.options.OptionsBuilder;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.concurrent.TimeUnit;@BenchmarkMode(Mode.Throughput) //测试类型：吞吐量@OutputTimeUnit(TimeUnit.MILLISECONDS)@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS) //预热2轮，每次1s@Measurement(iterations = 5, time = 3, timeUnit = TimeUnit.SECONDS) //测试5轮，每次3s@Fork(1) //fork1个线程@State(Scope.Thread) //每个测试线程一个实例public class HashMapTest &#123; public static Map&lt;String, String&gt; testMap = new HashMap() &#123;&#123; for (int i = 0; i &lt; 10; i++) &#123; put(\"key\" + i, \"val\" + i); &#125; &#125;&#125;; public static void main(String[] args) throws RunnerException &#123; Options opt = new OptionsBuilder() .include(HashMapTest.class.getSimpleName()) // 要导入的测试类 .output(\"d:/test/map_test.log\") // 输出测试结果的文件 .build(); new Runner(opt).run(); // 执行测试 &#125; @Benchmark public static void entrySetTest() &#123; Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = testMap.entrySet().iterator(); while (iterator.hasNext()) &#123; Map.Entry&lt;String, String&gt; entry = iterator.next(); System.out.println(entry.getKey() + \" ------ \" + entry.getValue()); &#125; &#125; @Benchmark public static void keySetTest() &#123; Iterator&lt;String&gt; iterator = testMap.keySet().iterator(); while (iterator.hasNext()) &#123; String key = iterator.next(); System.out.println(key + \" ------ \" + testMap.get(key)); &#125; &#125; @Benchmark public static void forEach4EntrySetTest() &#123; for (Map.Entry&lt;String, String&gt; entry : testMap.entrySet()) &#123; System.out.println(entry.getKey() + \" ------ \" + entry.getValue()); &#125; &#125; @Benchmark public static void forEach4KeySetTest() &#123; for (String key : testMap.keySet()) &#123; System.out.println(key + \" ------ \" + testMap.get(key)); &#125; &#125; @Benchmark public static void lambdaTest() &#123; testMap.forEach((key, value) -&gt; &#123; System.out.println(key + \" ------ \" + value); &#125;); &#125; @Benchmark public static void streamTest() &#123; testMap.entrySet().stream().forEach((entry) -&gt; &#123; System.out.println(entry.getKey() + \" ------ \" + entry.getValue()); &#125;); &#125; @Benchmark public static void parallelStreamTest() &#123; testMap.entrySet().parallelStream().forEach((entry) -&gt; &#123; System.out.println(entry.getKey() + \" ------ \" + entry.getValue()); &#125;); &#125;&#125; JMH（Java Microbenchmark Harness，JAVA 微基准测试套件）是 Oracle 官方提供的性能测试工具。 测试结束从 log 日志文件中获取相关的信息片段： 12345678Benchmark Mode Cnt Score Error UnitsHashMapTest.entrySetTest thrpt 5 2.725 ± 0.319 ops&#x2F;msHashMapTest.forEach4EntrySetTest thrpt 5 2.947 ± 0.416 ops&#x2F;msHashMapTest.forEach4KeySetTest thrpt 5 2.914 ± 0.701 ops&#x2F;msHashMapTest.keySetTest thrpt 5 2.799 ± 0.294 ops&#x2F;msHashMapTest.lambdaTest thrpt 5 2.850 ± 0.455 ops&#x2F;msHashMapTest.parallelStreamTest thrpt 5 2.420 ± 0.581 ops&#x2F;msHashMapTest.streamTest thrpt 5 2.811 ± 0.390 ops&#x2F;ms 其中 Score 列表示平均执行时间， ± 符号表示误差。从测试结果可以看出有快有慢，其实各种遍历方法在性能方面差别不是很大。 以上测试可能存在误差，毕竟每天机器的配置环境什么都不太一样，仅供参考 结语其实以上主要是为了分享几种遍历 HashMap 的方式，具体性能测试，甚至安全测试不是主要内容。而且测试代码作者也是参考网络上的文章。","categories":[],"tags":[],"keywords":[]},{"title":"Class.forName和ClassLoader","slug":"Class.forName和ClassLoader","date":"2020-06-25T13:02:41.821Z","updated":"2020-06-07T17:48:02.792Z","comments":true,"path":"583267688.html","link":"","permalink":"http://lili40342.github.io/583267688.html","excerpt":"","text":"开始在 Java 中，Class.forName() 和 ClassLoader 用的其实并不是很多，仔细回忆这两个东西，您是在什么时候才用过它们呢？？？其实随着您的回忆当初在学习 Java 连接数据库的时候你用到 Class.forName() ，而 ClassLoader 应该是在我们熟悉的 Spring 框架中的 IOC 的实现用的较多了。 稍作分析在 Java 中 Class.forName() 和 ClassLoader 可以”粗浅”的理解他们都是对类进行加载。ClassLoader 可以实现的功能是通过一个类的全限定名来获取描述此类的二进制字节流，获取到二进制流后放到JVM中。Class.forName() 方法实际上也是调用的ClassLoader 来实现的，其实我们通过 Class.forName() 的源码就可以看到： 123456@CallerSensitivepublic static Class&lt;?&gt; forName(String className) throws ClassNotFoundException &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); return forName0(className, true, ClassLoader.getClassLoader(caller), caller);&#125; 最后的 return 中调用了一个 forName0 方法，方法的第二个参数默认是 true，通过阅读源码得知这个参数代表是否对加载的类进行初始化，设置为 true 时会类进行初始化，代表会执行类中的静态代码块，以及对静态变量的赋值等操作。 其实在 Class.java 类中还有另外一个 forName(String name, boolean initialize, ClassLoader loader) 的静态方法： 123456789101112131415161718192021@CallerSensitivepublic static Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader) throws ClassNotFoundException&#123; Class&lt;?&gt; caller = null; SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; // Reflective call to get caller class is only needed if a security manager // is present. Avoid the overhead of making this call otherwise. caller = Reflection.getCallerClass(); if (sun.misc.VM.isSystemDomainLoader(loader)) &#123; ClassLoader ccl = ClassLoader.getClassLoader(caller); if (!sun.misc.VM.isSystemDomainLoader(ccl)) &#123; sm.checkPermission( SecurityConstants.GET_CLASSLOADER_PERMISSION); &#125; &#125; &#125; return forName0(name, initialize, loader, caller);&#125; 很明显，这个方法属于 forName() 的重载，仔细看你会发现它最后也是 return 了一个 forName0，很明显这个 Class.forName() 完全可以对第二个参数 boolean initialize 进行自我控制，可以进行手动选择在加载类的时候是否要对类进行初始化。 举例举个案例说一下吧，定义一个含有静态代码块，静态变量，静态方法（可以赋值给静态变量）的类： 123456789101112131415package com.wlee.test;public class DemoClass &#123; static &#123; System.out.println(\"执行了 - 静态代码块\"); &#125; private static String filed = method(); public static String method() &#123; System.out.println(\"执行了 - 静态方法\"); System.out.println(\"执行了 - 静态变量赋值\"); return \"执行了 - 静态变量赋值\"; &#125;&#125; 使用 Class.forName() 进行测试： 123456789101112package com.wlee.test;import org.junit.jupiter.api.Test;public class DemoTest &#123; @Test public void test() throws ClassNotFoundException &#123;//Class.forName进行测试 Class.forName(\"com.wlee.test.DemoClass\"); System.out.println(\"------执行结束------\"); &#125;&#125; 运行结果： 1234执行了 - 静态代码块执行了 - 静态方法执行了 - 静态变量赋值------执行结束------ 使用 ClassLoader 进行测试： 123456789101112131415161718package com.wlee.test;import org.junit.jupiter.api.Test;public class DemoTest &#123; @Test public void test() throws ClassNotFoundException &#123;//Class.forName进行测试 Class.forName(\"com.wlee.test.DemoClass\"); System.out.println(\"------执行结束------\"); &#125; @Test public void test2() throws ClassNotFoundException &#123;//ClassLoader进行测试 ClassLoader.getSystemClassLoader().loadClass(\"com.wlee.test.DemoClass\"); System.out.println(\"------执行结束------\"); &#125;&#125; 运行 test2() 的结果： 1------执行结束------ 很明显，Class.forName() 默认的在加载类的时候将类进了初始化，而 ClassLoader 的 loadClass 并没有对类进行初始化，只是把类加载到了虚拟机 JVM 中了。 应用场景看到上面的举例之后，想想 Class.forName() 的应用，就是在 JDBC 中使用，通过使用 Class.forName() 方法来加载数据库连接驱动。其实很好理解，我们利用 JDBC 如果去连接数据库？？？第一步通过 Class.forName() 加载数据库驱动，通过我们分析知道 Class.forName() 会自动初始化类，因为 JDBC 中明确规定要求 Driver(数据库驱动)类必须向 DriverManager 注册自己，通过观看数据库连接驱动类的源码就可以知道它为什么要用 Class.forName() 了： 以MySQL驱动为例源码片段如下： 12345678910111213141516171819202122public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; // // Register ourselves with the DriverManager // static &#123; try &#123; java.sql.DriverManager.registerDriver(new Driver()); &#125; catch (SQLException E) &#123; throw new RuntimeException(\"Can't register driver!\"); &#125; &#125; /** * Construct a new driver and register it with DriverManager * * @throws SQLException * if a database error occurs. */ public Driver() throws SQLException &#123; // Required for Class.forName().newInstance() &#125;&#125; 我们看到 Driver 注册到 DriverManager 中的操作写在了静态代码块中，这就是为什么在写 JDBC 时使用 Class.forName() 的原因了。至于 ClassLoader 我们就不做太细致的研究了，如果你有兴趣请移步“Java中的ClassLoader” 。","categories":[],"tags":[],"keywords":[]},{"title":"Lombok的分析与讨论","slug":"Lombok的分析与讨论","date":"2020-06-16T12:37:15.000Z","updated":"2020-06-25T12:46:23.844Z","comments":true,"path":"2358994905.html","link":"","permalink":"http://lili40342.github.io/2358994905.html","excerpt":"","text":"前言Lombok 接触也是近些日子的事，在没有接触或者还没知道 Lombok 的时候，你的 Entity 是怎么写的？我觉得没有什么特别之处吧，它不还是老样子，定义完了属性然后就是 getter 与 setter，充其量对其构造方法进行定义与处理一下，或者相关的需要特殊处理的方法罢了。所以在没有出现或者还没去接触 Lombok 的时候，不是一样纵横开发江湖中。 近几日在网上看到一些博文对 Lombok 的使用和分析，有赞美也有抨击的，作者也准备说一下对 Lombok 的看法吧。 Lombok是什么Lombok 是一个可以通过简单的注解的形式来帮助我们简化消除一些必须有但显得很臃肿的 Java 代码的工具。简单来说，比如我们新建了一个 Entity 类，然后在其中写了几个属性，然后通常情况下我们需要手动去建立 getter 和 setter 方法啊，构造方法等等之类的，Lombok 的作用就是为了省去我们手动创建这些代码的麻烦，它能够在我们编译源码的时候自动帮我们生成这些方法（当然它还有一些其他的作用）。 Lombok如何使用Lombok 是一个开源项目，那么 Lombok 是做什么呢？其实很简单，一个最简单的例子就是能够通过添加注解自动生成一些方法，使我们代码更加简洁易懂。例如下面一个类：（不管是 Gradle 项目还是 Maven 项目请自行引入 Lombok 支持）。 12345678910111213141516@Datapublic class TestEntity &#123; private String id; private String name;&#125;public class Test &#123; public static void main(String[] args) &#123; TestEntity e = new TestEntity(); e.setId(\"123\"); e.setName(\"Lee\"); System.out.println(e.getId()); System.out.println(e.getName()); &#125;&#125; 非常简单的一段代码，我们使用 Lombok 提供的 Data 注解，在没有写 get、set 方法的时候也能够使用其 get、set 方法。如果看它编译过后的 class 文件，可以看到自动生成了 get、set 方法（当然还有一些其他方法）。 运行时注解与编译时注解当然 Lombok 的功能不止如此，还有很多其他的注解帮助我们简便开发，网上有许多的关于 Lombok 的使用方法，这里就不再啰嗦了。正常情况下我们在项目中注解，不管是自定义的注解或者是类似 Spring 框架中的注解等等，大多都是运行时注解，运行时注解大部分都是通过反射来实现的。而 Lombok 是使用编译时注解实现的。那么编译时注解是什么呢？ 注解（也被成为元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。 Java 中的注解分为运行时注解和编译时注解，运行时注解就是我们经常使用的在程序运行时通过反射得到我们注解的信息，然后再做一些操作。而编译时注解是什么呢？就是在程序在编译期间通过注解处理器进行处理。 编译期：Java 语言的编译期是一段不确定的操作过程，因为它可能是将 xxx.java 文件转化成 xxx.class 文件的过程，也可能是指将字节码转变成机器码的过程，还可能是直接将 xxx.java 编译成本地机器代码的过程。 运行期：从 JVM 加载字节码文件到内存中，到最后使用完毕以后卸载的过程都属于运行期的范畴。 如果想了解什么是运行时注解和编译时注解，网上的案例很多，请自行查阅，这里不做具体研究和分析了。 Lombok的“好”与“坏”，“爱”与“恨”如果您读到文章这个地方了，想必您对 Lombok 已经有了一段时间的了解，或者您已经用了很久了，或者是正准备使用 Lombok，有甚至您可能要放弃 Lombok 了。 从一个普通的 Entity 类说起来吧，在没有出现 Lombok 或者没使用 Lombok 的时候，您的 Entity 类肯定是各种 get、set方法，各种构造方法和一切其他的特殊处理方法。更甚至如果 Entity 类中的属性偏多的情况下，这样这个 Entity 类就会显得更加臃肿和繁琐。如果您把这些东西都认为是 Java 语言的“缺陷”，实在不敢苟同，毕竟不管是哪种计算机语言都有它的优点与缺点，如果没有这些优点与缺点，就不会有各种计算机语言出现或者是版本与版本之间的更新，这是一个良性过程。那好吧，Lombok 出现了，它可以通过简单的几个注解让您的 Entity 类变的十分清爽，它可以让您少写太多太多的代码了，简直就是“神器”。Lombok 可以让臃肿的 Entity 类一下子变得十分炫酷。 当一个新技术或者新东西出现的时候，用到的人都会觉得它是如此炫酷和带劲，但是当它出现了很久，用的人多了时间长了，那各种各样的问题就接踵而至。其实这是一个很正常的事，毕竟社会是进步的，谁都是想越来越好。那随着时间的推移，使用 Lombok 会带来哪些问题呢？作者近期读了不少有关 Lombok 的文章，大致的总结了一下： JDK版本问题。 团队开发中的问题。 代码可读性的问题。 其他问题。 其实这些问题，很好理解，很明显社会它在进步，作为程序员的您总觉得需要它更适合您才行。 有些文章里说到当在升级 JDK 版本的时候，Lombok 不能用了，不好使了。然后随着出现的问题就是将 Lombok 在代码中移除，然后一下子回到“解放前”，随后还是得自己生成 get、set方法等等。试问，如果是一个长期运转或者成型的项目或者产品，谁会去随便升级 JDK 版本。别说 JDK 新版本有些新的改进，我觉得它未必必须要用到吧，作者是一个有13年长的老码农，几年前用 JDK 1.5甚至 JDK 1.4的项目还在维护中（看到这里，老码农肯定明白我为什么把 JDK5 叫做 JDK1.5），那个时候没有 Lombok，那不是该怎么撸代码还得怎么撸啊。而且不太相信作为一个公司的领导或者老大，把公司一些成型的项目或产品最底层所谓的 JDK 随便去升级，第一没有精力，第二没人去干。说到这里了，我认为当您升级 JDK 版本从而引发 Lombok 不能用了，我觉得 Lombok 肯定在后续的版本里去解决或者更新这个问题，就是我刚才说的，任何技术的出现都有它的有点与缺点，毕竟社会是进步的，技术是不断更新的。 那么团队开发中的问题，认为项目中使用了 Lombok，作为项目参与者也得强迫安装 Lombok 的插件。作者觉得这是一件很平常不过的事情了，难道整个团队不去统一开发工具，不去统一开发规则，不去统一开发环境吗？这种情况不太可能吧。至今作者还没发现，哪个项目组开发一个项目或者产品，开发工具和开发环境五花八门的，可能会存在个别的开发工具和开发环境的配置，但是绝对不是全都不统一吧。作者公司曾经招聘过一个小姐姐程序员，当初她是大学实习来的，入职了之后发现她竟然不用鼠标，问其原因她竟然解释“不用鼠标是老师教的，搞程序用不上鼠标”。哎呀我去，不是老师传授的有误会就是这个学生理解的有偏差。是，写代码是用不上鼠标，但是它不可能老不用。别说用“触摸板”，如果您不是“触摸板”神将人员，用鼠标不是更美滋滋。emm，有点跑题。 至于一些代码可读性问题，一些其他问题。没有 Lombok 的时候没啥问题？有了 Lombok 就出问题了？！作者觉得这就是所谓的欲望唆使的呗，没 Lombok 的时候就没问题了，不能撸代码了？有 Lombok 就出问题了？！其实就是社会进步的原因罢了。 结语Lombok 本身是一个优秀的 Java 代码库而已，它只是简化了 Java 的编码，为 Java 代码的精简提供了一种方式。但在没人要求您必须要使用 Lombok，使用 Lombok，完全是您在各种评估下，各种统一开发工具和开发环境下，结合整个团队目前的状况，来决定到底用不用 Lombok。 以前只是作者对 Lombok 的看法，博文中的内容不映射任何人与事，只是见解而已。","categories":[{"name":"编程笔记","slug":"编程笔记","permalink":"http://lili40342.github.io/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Lombok","slug":"Lombok","permalink":"http://lili40342.github.io/tags/Lombok/"}],"keywords":[{"name":"编程笔记","slug":"编程笔记","permalink":"http://lili40342.github.io/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"}]}]}